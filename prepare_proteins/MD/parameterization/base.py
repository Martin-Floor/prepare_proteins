import os
from dataclasses import dataclass, field
from typing import Any, Dict, Optional, Type


@dataclass
class ParameterizationResult:
    """Container describing the inputs generated by a parameterization backend."""

    input_format: str
    files: Dict[str, str] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def with_file(self, key: str, path: Optional[str]) -> "ParameterizationResult":
        """Return a new result with an additional file entry."""
        if path:
            self.files[key] = path
        return self

    @property
    def prmtop_path(self) -> Optional[str]:
        return self.files.get("prmtop")

    @property
    def coordinates_path(self) -> Optional[str]:
        for key in ("inpcrd", "rst7", "coordinates"):
            if key in self.files:
                return self.files[key]
        return None


class ParameterizationBackend:
    """Base backend for generating simulation inputs."""

    name: str = "base"
    input_format: str = "base"

    def __init__(self, **options: Any) -> None:
        self.options = options

    def prepare_model(self, openmm_md, parameters_folder: str, **kwargs: Any) -> ParameterizationResult:
        """Generate (or ensure the presence of) simulation inputs for ``openmm_md``."""
        raise NotImplementedError(f"{self.__class__.__name__} does not implement prepare_model.")

    def describe_model(self, openmm_md) -> ParameterizationResult:
        """Build a ``ParameterizationResult`` from attributes already stored on ``openmm_md``."""
        result = ParameterizationResult(input_format=self.input_format)
        prmtop = getattr(openmm_md, "prmtop_file", None)
        coordinates = getattr(openmm_md, "inpcrd_file", None)
        if prmtop:
            result.with_file("prmtop", prmtop)
        if coordinates:
            result.with_file("coordinates", coordinates)
            ext = os.path.splitext(coordinates)[1].lstrip(".").lower()
            if ext:
                result.with_file(ext, coordinates)
        return result


_BACKEND_REGISTRY: Dict[str, Type[ParameterizationBackend]] = {}


def register_backend(cls: Type[ParameterizationBackend]) -> Type[ParameterizationBackend]:
    """Register ``cls`` in the backend registry."""
    name = getattr(cls, "name", None)
    if not name:
        raise ValueError("Cannot register backend without a name.")
    _BACKEND_REGISTRY[name.lower()] = cls
    return cls


def get_backend(name: str, **options: Any) -> ParameterizationBackend:
    """Return an instance of the backend ``name`` configured with ``options``."""
    try:
        backend_cls = _BACKEND_REGISTRY[name.lower()]
    except KeyError as exc:
        available = ", ".join(sorted(_BACKEND_REGISTRY))
        raise ValueError(f"Unknown parameterization backend '{name}'. Available: {available or 'none'}") from exc
    return backend_cls(**options)


def available_backends() -> Dict[str, Type[ParameterizationBackend]]:
    """Return a copy of the registered backends mapping."""
    return dict(_BACKEND_REGISTRY)

